import React from 'react';
import { getFocusIndexes, map, mapFocusToLineNumbers, parseExtremes, mapWithDefault, splitParts, hasColumns, parsePartToObject, withDefault, getColor, ColorName, getCodeColors } from '@code-hike/utils';
import { diffLines } from 'diff';
import { useSpring } from 'use-spring';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var useLayoutEffect = typeof window !== "undefined"
    ? React.useLayoutEffect
    : React.useEffect;
var DEFAULT_WIDTH = 200;
// type DimensionsResult = {
//   width: number
//   height: number
//   lineWidths: { prev: number; next: number }
//   lineHeight: number
//   colWidth: number
// }
function useDimensions(code, focus, minColumns, lineNumbers, deps) {
    var _a = __read(React.useState(null), 2), dimensions = _a[0], setDimensions = _a[1];
    var windowWidth = useWindowWidth();
    var prevLineRef = React.useRef(null);
    var _b = React.useMemo(function () {
        var prevLongestLine = getLongestLine(code.prev, focus.prev);
        var nextLongestLine = getLongestLine(code.next, focus.next);
        var lines = (code.prev || code.next)
            .trim()
            .split(newlineRe);
        var lineCount = lines.length;
        var element = (React.createElement("code", { className: "ch-code-scroll-parent" },
            React.createElement("br", null),
            lines.map(function (line, i) { return (React.createElement("div", { ref: line === prevLongestLine
                    ? prevLineRef
                    : undefined, key: i },
                lineNumbers ? (React.createElement("span", { className: "ch-code-line-number" },
                    "_",
                    lineCount)) : undefined,
                React.createElement("div", { style: { display: "inline-block" } },
                    React.createElement("span", null, line)))); }),
            React.createElement("br", null)));
        return { prevLongestLine: prevLongestLine, nextLongestLine: nextLongestLine, element: element };
    }, [code]), prevLongestLine = _b.prevLongestLine, nextLongestLine = _b.nextLongestLine, element = _b.element;
    var allDeps = __spread(deps, [
        windowWidth,
        prevLongestLine,
        nextLongestLine,
        minColumns,
    ]);
    useLayoutEffect(function () {
        var _a;
        if (prevLineRef.current) {
            var pll = prevLineRef.current;
            var codeElement = pll === null || pll === void 0 ? void 0 : pll.parentElement;
            // TODO is it clientWidth or clientRect?
            var lineContentDiv = pll === null || pll === void 0 ? void 0 : pll.querySelector(":scope > div");
            var lineNumberSpan = pll === null || pll === void 0 ? void 0 : pll.querySelector(":scope > span");
            var lnw = lineNumberSpan
                ? getWidthWithPadding(lineNumberSpan)
                : 0;
            var plw = getWidthWithoutPadding(lineContentDiv);
            var colWidth = plw / prevLongestLine.length || 1;
            var nlw = nextLongestLine.length * colWidth;
            var lineHeight = (_a = getHeightWithoutPadding(lineContentDiv)) !== null && _a !== void 0 ? _a : 20;
            var d = {
                containerWidth: getWidthWithoutPadding(codeElement.parentElement),
                containerHeight: getHeightWithoutPadding(codeElement.parentElement),
                lineWidths: [
                    plw || nlw || DEFAULT_WIDTH,
                    nlw || plw || DEFAULT_WIDTH,
                ],
                lineWidth: [
                    Math.max(plw || nlw || DEFAULT_WIDTH, colWidth * minColumns),
                    Math.max(nlw || plw || DEFAULT_WIDTH, colWidth * minColumns),
                ],
                lineHeight: lineHeight,
                colWidth: colWidth,
                lineNumberWidth: lnw,
                deps: allDeps,
            };
            setDimensions(d);
            // console.log({ d })
        }
    }, [allDeps]);
    if (!dimensions ||
        depsChanged(dimensions.deps, allDeps)) {
        return { element: element, dimensions: null };
    }
    else {
        return { element: element, dimensions: dimensions };
    }
}
var newlineRe = /\r\n|\r|\n/;
function getLongestLine(code, focus) {
    var lines = code ? code.split(newlineRe) : [""];
    var focusIndexes = getFocusIndexes(focus, lines);
    var longestLine = "";
    lines.forEach(function (line, index) {
        if (focusIndexes.includes(index) &&
            line.length > longestLine.length) {
            longestLine = line;
        }
    });
    return longestLine;
}
function getWidthWithoutPadding(element) {
    var computedStyle = getComputedStyle(element);
    return (parseFloat(computedStyle.width) -
        parseFloat(computedStyle.paddingLeft) -
        parseFloat(computedStyle.paddingRight));
}
function getWidthWithPadding(element) {
    var computedStyle = getComputedStyle(element);
    return parseFloat(computedStyle.width);
}
function getHeightWithoutPadding(element) {
    if (!element)
        return null;
    var computedStyle = getComputedStyle(element);
    return (parseFloat(computedStyle.height) -
        parseFloat(computedStyle.paddingTop) -
        parseFloat(computedStyle.paddingBottom));
}
function depsChanged(oldDeps, newDeps) {
    for (var i = 0; i < oldDeps.length; i++) {
        if (oldDeps[i] !== newDeps[i])
            return true;
    }
    return false;
}
function useWindowWidth() {
    var _a = __read(React.useState(undefined), 2), width = _a[0], setWidth = _a[1];
    React.useEffect(function () {
        function handleResize() {
            setWidth(window.innerWidth);
        }
        window.addEventListener("resize", handleResize);
        return function () {
            return window.removeEventListener("resize", handleResize);
        };
    }, []);
    return width;
}

function mergeLines(code, lines) {
    var enterIndex = 0;
    var exitIndex = 0;
    var indexes = diff(code);
    var newLines = indexes.map(function (index) {
        if (index.next === undefined) {
            return __assign(__assign({}, lines.prev[index.prev]), { lineNumber: {
                    prev: index.prev + 1,
                }, move: "exit", enterIndex: null, exitIndex: exitIndex++ });
        }
        if (index.prev === undefined) {
            return __assign(__assign({}, lines.next[index.next]), { lineNumber: {
                    next: index.next + 1,
                }, move: "enter", enterIndex: enterIndex++, exitIndex: null });
        }
        return __assign(__assign({}, lines.prev[index.prev]), { lineNumber: {
                prev: index.prev + 1,
                next: index.next + 1,
            }, move: "stay", enterIndex: null, exitIndex: null });
    });
    return {
        lines: newLines,
        enterCount: enterIndex,
        exitCount: exitIndex,
    };
}
/**
 * Returns a list of pairs of line indexes:
 *
 * For example if lines 2 and 3 were removed
 * and two lines where added at the end:
 *  0 0
 *  1 -
 *  2 -
 *  3 1
 *  - 2
 *  - 3
 */
function diff(code) {
    var changes = diffLines(code.prev, code.next);
    var indexes = [];
    var prevIndex = 0;
    var nextIndex = 0;
    changes.forEach(function (change) {
        if (change.added) {
            for (var i = 0; i < change.count; i++) {
                indexes.push({ next: nextIndex++ });
            }
        }
        else if (change.removed) {
            for (var i = 0; i < change.count; i++) {
                indexes.push({ prev: prevIndex++ });
            }
        }
        else {
            for (var i = 0; i < change.count; i++) {
                indexes.push({
                    prev: prevIndex++,
                    next: nextIndex++,
                });
            }
        }
    });
    return indexes;
}

function splitByFocus(mergedCode, focus, annotations) {
    var lines = mergedCode.lines, mergedCodeRest = __rest(mergedCode, ["lines"]);
    var focusByLineNumber = map(focus, function (focus) {
        return mapFocusToLineNumbers(focus, lines);
    });
    var splittedLines = lines.map(function (line) {
        var tokens = line.tokens, rest = __rest(line, ["tokens"]);
        var lineFocus = {
            prev: line.lineNumber.prev
                ? focusByLineNumber.prev[line.lineNumber.prev]
                : false,
            next: line.lineNumber.next
                ? focusByLineNumber.next[line.lineNumber.next]
                : false,
        };
        var lineAnnotations = {
            prev: line.lineNumber.prev
                ? annotations.prev[line.lineNumber.prev] || []
                : [],
            next: line.lineNumber.next
                ? annotations.next[line.lineNumber.next] || []
                : [],
        };
        return __assign({ focused: map(lineFocus, function (focus) { return !!focus; }), groups: getTokenGroups(tokens, lineFocus, lineAnnotations) }, rest);
    });
    var focusedLineNumbers = map(focusByLineNumber, function (focusByLineNumber) {
        return Object.keys(focusByLineNumber).map(function (k) { return Number(k); });
    });
    var firstFocusedLineNumber = map(focusedLineNumbers, function (focusedLineNumbers) { return Math.min.apply(Math, __spread(focusedLineNumbers)); });
    var lastFocusedLineNumber = map(focusedLineNumbers, function (focusedLineNumbers) { return Math.max.apply(Math, __spread(focusedLineNumbers)); });
    return __assign({ lines: splittedLines, firstFocusedLineNumber: firstFocusedLineNumber,
        lastFocusedLineNumber: lastFocusedLineNumber }, mergedCodeRest);
}
/**
 * Get the least amount of groups where no consecutive groups have
 * the same combination of prevFocus, nextFocus, prevAnnotation, nextAnnotation.
 */
function getTokenGroups(tokens, focus, annotations) {
    var focusExtremes = map(focus, function (focus) {
        return Array.isArray(focus) ? focus : [];
    });
    var annotationExtremes = map(annotations, function (annotations) {
        return annotations.map(function (_a) {
            var columnNumbers = _a.columnNumbers;
            return columnNumbers;
        });
    });
    var allExtremes = __spread(focusExtremes.prev, focusExtremes.next, annotationExtremes.prev, annotationExtremes.next);
    var splittedTokens = splitTokens(tokens, allExtremes);
    var startIndex = 0;
    var currentGroup = null;
    var groups = [];
    splittedTokens.forEach(function (token) {
        var newPrevFocus = isIn(startIndex, focus.prev);
        var newNextFocus = isIn(startIndex, focus.next);
        var newPrevAnnotation = getAnnotation(startIndex, annotations.prev);
        var newNextAnnotation = getAnnotation(startIndex, annotations.next);
        if (!currentGroup ||
            currentGroup.focused.prev !== newPrevFocus ||
            currentGroup.focused.next !== newNextFocus ||
            currentGroup.annotation.prev !== newPrevAnnotation ||
            currentGroup.annotation.next !== newNextAnnotation) {
            currentGroup = {
                focused: {
                    prev: newPrevFocus,
                    next: newNextFocus,
                },
                tokens: [],
                annotation: {
                    prev: newPrevAnnotation,
                    next: newNextAnnotation,
                },
            };
            groups.push(currentGroup);
        }
        currentGroup === null || currentGroup === void 0 ? void 0 : currentGroup.tokens.push(token);
        startIndex += token.content.length;
    });
    return groups.map(function (group) {
        return ({
            focused: group.focused,
            tokens: group.tokens,
            element: getGroupElement(group),
        });
    });
}
function getGroupElement(group) {
    return (React.createElement(React.Fragment, null, group.tokens.map(function (_a, i) {
        var content = _a.content, props = _a.props;
        return (React.createElement("span", __assign({}, props, { key: i + 1 }), content));
    })));
}
/**
 * Split a list of tokens into a more fine-graned list of tokens
 *
 * tokens: [abc][defg]
 * extremes: [1:2,2:5]
 * result tokens: [ab][c][de][fg]
 *
 */
function splitTokens(tokens, extremes) {
    var splitIndexes = __spread(extremes.map(function (e) { return e.start - 1; }), extremes.map(function (e) { return e.end; }));
    var oldTokens = tokens;
    splitIndexes.forEach(function (splitIndex) {
        var newTokens = [];
        var i = 0;
        oldTokens.forEach(function (token) {
            var startIndex = i;
            var endIndex = i + token.content.length;
            var shouldSplit = startIndex < splitIndex && splitIndex < endIndex;
            if (shouldSplit) {
                var sliceIndex = splitIndex - startIndex;
                var content0 = token.content.slice(0, sliceIndex);
                var content1 = token.content.slice(sliceIndex);
                newTokens.push(__assign(__assign({}, token), { content: content0 }));
                newTokens.push(__assign(__assign({}, token), { content: content1 }));
            }
            else {
                newTokens.push(token);
            }
            i = endIndex;
        });
        oldTokens = newTokens;
    });
    return oldTokens;
}
function isIn(index, intervals) {
    if (!Array.isArray(intervals)) {
        return intervals;
    }
    return intervals.some(function (_a) {
        var start = _a.start, end = _a.end;
        return start - 1 <= index && index < end;
    });
}
function getAnnotation(index, annotations) {
    return annotations.find(function (_a) {
        var columnNumbers = _a.columnNumbers;
        return columnNumbers.start - 1 <= index &&
            index < columnNumbers.end;
    });
}

function tween(params, t) {
    if (params.fixed)
        return params.value;
    var _a = __read(params.interval, 2), start = _a[0], end = _a[1];
    var _b = __read(params.extremes, 2), from = _b[0], to = _b[1];
    if (t < start)
        return from;
    if (t > end)
        return to;
    var x = (t - start) / (end - start);
    var ease = params.ease || easing.linear;
    return from + ease(x) * (to - from);
}
function stagger(_a, index, count) {
    var _b = __read(_a, 2), start = _b[0], end = _b[1];
    if (count <= 1)
        return [start, end];
    var totalDuration = end - start;
    var stepDuration = totalDuration / Math.pow(count, 1 / 8);
    var tick = (totalDuration - stepDuration) / (count - 1);
    var stepStart = start + tick * index;
    var stepEnd = stepStart + stepDuration;
    return [stepStart, stepEnd];
}
var easing = {
    linear: function (t) {
        return t;
    },
    easeInQuad: function (t) {
        return t * t;
    },
    easeOutQuad: function (t) {
        return t * (2 - t);
    },
    easeInOutCubic: function (t) {
        return t < 0.5
            ? 4 * t * t * t
            : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
};

function getLinesWithElements(lines, verticalInterval, enterCount, exitCount) {
    // startY is the progress when we start moving vertically
    // endY is when we stop
    var _a = __read(verticalInterval, 2), startY = _a[0], endY = _a[1];
    return lines.map(function (line) {
        var lineIndex = map(line.lineNumber, function (ln) { return ln && ln - 1; });
        var enterIndex = line.enterIndex, exitIndex = line.exitIndex;
        var tweenY = line.move === "exit"
            ? { fixed: true, value: lineIndex.prev }
            : line.move === "enter"
                ? { fixed: true, value: lineIndex.next }
                : {
                    fixed: false,
                    extremes: [lineIndex.prev, lineIndex.next],
                    interval: [startY, endY],
                    ease: easing.easeInOutCubic,
                };
        var tweenX = line.move === "exit"
            ? {
                fixed: false,
                extremes: [0, -1],
                ease: easing.easeInQuad,
                interval: stagger([0, startY], exitIndex, exitCount),
            }
            : line.move === "enter"
                ? {
                    fixed: false,
                    extremes: [1, 0],
                    ease: easing.easeOutQuad,
                    interval: stagger([endY, 1], enterIndex, enterCount),
                }
                : { fixed: true, value: 0 };
        return __assign(__assign({}, line), { tweenX: tweenX,
            tweenY: tweenY });
    });
}

function parseAnnotations(annotations, theme) {
    // split annotations with multiple parts in the focus string
    // "1:2,3[4:5]" becomes  two annotations "1:2" and "3[4:5]"
    var expandedAnnotations = mapWithDefault(annotations, [], function (annotations) {
        return annotations.flatMap(function (annotation) {
            return splitParts(annotation.focus).map(function (part) { return (__assign(__assign({}, annotation), { focus: part })); });
        });
    });
    var inlineCodeAnnotations = mapWithDefault(expandedAnnotations, [], function (annotations) { return annotations.filter(isInline); });
    var multilineCodeAnnotations = mapWithDefault(expandedAnnotations, [], function (annotations) { return annotations.filter(function (a) { return !isInline(a); }); });
    return {
        inlineAnnotations: map(inlineCodeAnnotations, function (annotations) {
            return parseInlineAnnotations(annotations, theme);
        }),
        multilineAnnotations: map(multilineCodeAnnotations, function (annotations) {
            return parseMultilineAnnotations(annotations, theme);
        }),
    };
}
function isInline(annotation) {
    return hasColumns(annotation.focus);
}
function parseInlineAnnotations(annotations, theme) {
    var annotationMap = {};
    annotations.forEach(function (annotation) {
        var focusMap = parsePartToObject(annotation.focus);
        var lineNumber = +Object.keys(focusMap)[0];
        var columnNumbersList = focusMap[lineNumber];
        var lineAnnotations = annotationMap[lineNumber] || [];
        lineAnnotations.push({
            columnNumbers: columnNumbersList[0],
            data: annotation.data,
            theme: theme,
            Component: annotation.Component ||
                defaultInlineComponent(),
        });
        annotationMap[lineNumber] = lineAnnotations;
    });
    return annotationMap;
}
function defaultInlineComponent(annotation, theme) {
    return function (_a) {
        var children = _a.children;
        return (React.createElement("span", { style: { outline: "red 1px solid" } }, children));
    };
}
function parseMultilineAnnotations(annotations, theme) {
    return annotations.map(function (annotation) {
        return {
            lineNumbers: parseExtremes(annotation.focus),
            data: annotation.data,
            theme: theme,
            Component: annotation.Component ||
                defaultMultilineComponent(annotation, theme),
        };
    });
}
function defaultMultilineComponent(annotation, theme) {
    // TODO handle missing bg
    var bg = (theme.colors["editor.lineHighlightBackground"] ||
        theme.colors["editor.selectionHighlightBackground"]);
    return function (_a) {
        var children = _a.children, style = _a.style;
        return (React.createElement("div", { style: __assign(__assign({}, style), { background: bg, cursor: "pointer" }), onClick: function (_) { return alert("clicked"); }, className: "ch-code-bg-annotation" },
            React.createElement("span", { className: "ch-code-bg-annotation-border", style: {
                    background: "#00a2d3",
                    width: "3px",
                    height: "100%",
                    position: "absolute",
                    left: 0,
                } }),
            children));
    };
}
// --- multiline
function annotateMultiline(lines, annotations) {
    return {
        prev: annotateMultilineSide(lines, annotations.prev, function (line) { return line.lineNumber.prev; }),
        next: annotateMultilineSide(lines, annotations.next, function (line) { return line.lineNumber.next; }),
    };
}
function annotateMultilineSide(lines, ogAnnotations, getLineNumber) {
    var annotations = __spread(ogAnnotations);
    annotations.sort(function (a, b) { return a.lineNumbers.start - b.lineNumbers.start; });
    var lineIndex = 0;
    var groups = [];
    while (lineIndex < lines.length) {
        var annotation = annotations[0];
        var line = lines[lineIndex];
        if (annotation &&
            getLineNumber(line) === annotation.lineNumbers.start) {
            // create annotation group
            var group = {
                lines: [],
                annotation: annotation,
            };
            while (line &&
                (!getLineNumber(line) ||
                    getLineNumber(line) <=
                        annotation.lineNumbers.end)) {
                group.lines.push(line);
                line = lines[++lineIndex];
            }
            groups.push(group);
            annotations.shift();
        }
        else if (!annotation) {
            // create unannotated group until the end
            groups.push({ lines: lines.slice(lineIndex) });
            lineIndex = lines.length;
        }
        else {
            // create unannotated group until next annotation
            var group = {
                lines: [],
            };
            while (line &&
                (!getLineNumber(line) ||
                    getLineNumber(line) <
                        annotation.lineNumbers.start)) {
                group.lines.push(line);
                line = lines[++lineIndex];
            }
            groups.push(group);
        }
    }
    return groups;
}
// --- inline
function annotateInline(lines, inlineAnnotations) {
    return lines.map(function (_a) {
        var groups = _a.groups, line = __rest(_a, ["groups"]);
        var lineNumber = line.lineNumber;
        var annotations = {
            prev: lineNumber.prev
                ? inlineAnnotations.prev[lineNumber.prev] || []
                : [],
            next: lineNumber.next
                ? inlineAnnotations.next[lineNumber.next] || []
                : [],
        };
        return __assign(__assign({}, line), { annotatedGroups: annotateLineTokenGroups(groups, annotations) });
    });
}
/**
 * Generate a list of annotated groups tweens
 * each annotated group contains a list of token groups and maybe an annotation.
 * The two annotated groups in a tween doesn't need to have the same token groups.
 */
function annotateLineTokenGroups(tokenGroups, annotations) {
    var prevTokenGroups = __spread(tokenGroups);
    var nextTokenGroups = __spread(tokenGroups);
    var prevAnnotations = __spread(annotations.prev);
    var nextAnnotations = __spread(annotations.next);
    var annotatedGroups = [];
    var prevColumn = 1;
    var nextColumn = 1;
    // iterate until we consume both lists of token groups
    while (prevTokenGroups.length > 0 ||
        nextTokenGroups.length > 0) {
        var prevAnnotation = prevAnnotations[0];
        var nextAnnotation = nextAnnotations[0];
        var isPrevAnnotationStarting = prevAnnotation &&
            prevAnnotation.columnNumbers.start === prevColumn;
        var isNextAnnotationStarting = nextAnnotation &&
            nextAnnotation.columnNumbers.start === nextColumn;
        if (prevColumn < nextColumn) {
            // if the prev list is behind we consume from prevTokenGroups
            if (isPrevAnnotationStarting) {
                // if there is an annotation starting at this point we consume until the annotation ends
                var end = prevAnnotation.columnNumbers.end + 1;
                annotatedGroups.push({
                    prev: {
                        annotation: prevAnnotation,
                        groups: shiftGroups(prevTokenGroups, prevColumn, end),
                    },
                });
                prevColumn = end;
                prevAnnotations.shift();
            }
            else {
                // if there isn't we consume until we sync with the next list or an annotation starts
                var end = Math.min(nextColumn, (prevAnnotation === null || prevAnnotation === void 0 ? void 0 : prevAnnotation.columnNumbers.start) || nextColumn);
                annotatedGroups.push({
                    prev: {
                        groups: shiftGroups(prevTokenGroups, prevColumn, end),
                    },
                });
                prevColumn = end;
            }
        }
        else if (prevColumn > nextColumn) {
            // if the next list is behind we consume from nextTokenGroups
            if (isNextAnnotationStarting) {
                // if there is an annotation starting at this point we consume until the annotation ends
                var end = nextAnnotation.columnNumbers.end + 1;
                annotatedGroups.push({
                    next: {
                        annotation: nextAnnotation,
                        groups: shiftGroups(nextTokenGroups, nextColumn, end),
                    },
                });
                nextColumn = end;
                nextAnnotations.shift();
            }
            else {
                // if there isn't we consume until we sync with the prev list or an annotation starts
                var end = Math.min(prevColumn, (nextAnnotation === null || nextAnnotation === void 0 ? void 0 : nextAnnotation.columnNumbers.start) || prevColumn);
                annotatedGroups.push({
                    next: {
                        groups: shiftGroups(nextTokenGroups, nextColumn, end),
                    },
                });
                nextColumn = end;
            }
        }
        else if (prevColumn == nextColumn) {
            // if we are at the same column in both lists we have 5 different cases
            if (isPrevAnnotationStarting &&
                isNextAnnotationStarting &&
                prevAnnotation.columnNumbers.end ===
                    nextAnnotation.columnNumbers.end) {
                // both annotations starts here and end at the same place, so we puth both in one tween annotated group
                var end = nextAnnotation.columnNumbers.end + 1;
                annotatedGroups.push({
                    prev: {
                        annotation: prevAnnotation,
                        groups: shiftGroups(prevTokenGroups, prevColumn, end),
                    },
                    next: {
                        annotation: nextAnnotation,
                        groups: shiftGroups(nextTokenGroups, nextColumn, end),
                    },
                });
                prevColumn = end;
                nextColumn = end;
                prevAnnotations.shift();
                nextAnnotations.shift();
            }
            else if (isPrevAnnotationStarting) {
                // if only the prev annotation starting at this point we consume until the annotation ends
                var end = prevAnnotation.columnNumbers.end + 1;
                annotatedGroups.push({
                    prev: {
                        annotation: prevAnnotation,
                        groups: shiftGroups(prevTokenGroups, prevColumn, end),
                    },
                });
                prevColumn = end;
                prevAnnotations.shift();
            }
            else if (isNextAnnotationStarting) {
                // same for the next annotation
                var end = nextAnnotation.columnNumbers.end + 1;
                annotatedGroups.push({
                    next: {
                        annotation: nextAnnotation,
                        groups: shiftGroups(nextTokenGroups, nextColumn, end),
                    },
                });
                nextColumn = end;
                nextAnnotations.shift();
            }
            else if (!prevAnnotation && !nextAnnotation) {
                // if there aren't any remaining annotation we add a last group
                annotatedGroups.push({
                    prev: { groups: prevTokenGroups },
                    next: { groups: nextTokenGroups },
                });
                // this is the last iteration
                prevTokenGroups = [];
                nextTokenGroups = [];
            }
            else {
                // if we still have annotations left we consume until the next one
                var end = Math.min((prevAnnotation === null || prevAnnotation === void 0 ? void 0 : prevAnnotation.columnNumbers.start) ||
                    Number.MAX_VALUE, (nextAnnotation === null || nextAnnotation === void 0 ? void 0 : nextAnnotation.columnNumbers.start) ||
                    Number.MAX_VALUE);
                annotatedGroups.push({
                    prev: {
                        groups: shiftGroups(prevTokenGroups, prevColumn, end),
                    },
                    next: {
                        groups: shiftGroups(nextTokenGroups, nextColumn, end),
                    },
                });
                prevColumn = end;
                nextColumn = end;
            }
        }
    }
    return annotatedGroups;
}
/**
 * Remove and return some groups from the beggining of the array
 * startColumn is the column at which the array is starting
 * (because other groups has been already removed)
 * newStartColumn is the first column that should stay in the array
 */
function shiftGroups(tokenGroups, startColumn, newStartColumn) {
    var removedGroups = [];
    var currentStartColumn = startColumn;
    while (currentStartColumn < newStartColumn) {
        var currentTokenGroup = tokenGroups.shift();
        removedGroups.push(currentTokenGroup);
        var length_1 = currentTokenGroup.tokens.reduce(function (a, t) { return a + t.content.length; }, 0);
        currentStartColumn += length_1;
    }
    return removedGroups;
}

function useStepParser(input) {
    var highlightedLines = input.highlightedLines, theme = input.theme, focus = input.focus;
    return React.useMemo(function () { return parse(input); }, [
        highlightedLines.prev,
        highlightedLines.next,
        focus.prev,
        focus.next,
        theme,
    ]);
}
function parse(_a) {
    var theme = _a.theme, focus = _a.focus, annotations = _a.annotations, highlightedLines = _a.highlightedLines;
    var normalCode = getCode(highlightedLines);
    var mergedCode = merge(normalCode, highlightedLines);
    var _b = parseAllAnnotations(annotations, theme), inlineAnnotations = _b.inlineAnnotations, multilineAnnotations = _b.multilineAnnotations;
    var focusedCode = splitLinesByFocus(mergedCode, withDefault(focus, null), inlineAnnotations);
    var annotatedCode = addAnnotations(focusedCode, inlineAnnotations, multilineAnnotations);
    var codeStep = addExtraStuff(annotatedCode, normalCode);
    // console.log({ codeStep })
    return codeStep;
}
// 0 - normalize
function getCode(highlightedLines) {
    return map(highlightedLines, function (lines) {
        return lines
            .map(function (line) { return line.tokens.map(function (t) { return t.content; }).join(""); })
            .join("\n")
            .trimEnd()
            .concat("\n");
    });
}
function merge(code, highlightedLines) {
    return mergeLines(code, highlightedLines);
}
function parseAllAnnotations(annotations, theme) {
    return parseAnnotations(annotations, theme);
}
function splitLinesByFocus(mergedCode, focus, annotations) {
    return splitByFocus(mergedCode, focus, annotations);
}
function addAnnotations(_a, inlineAnnotations, annotations) {
    var lines = _a.lines, focusedCode = __rest(_a, ["lines"]);
    var annotatedLines = annotateInline(lines, inlineAnnotations);
    var lineGroups = annotateMultiline(annotatedLines, annotations);
    return __assign(__assign({}, focusedCode), { lineGroups: lineGroups, lineCount: {
            prev: lines.filter(function (l) { return l.lineNumber.prev != null; })
                .length,
            next: lines.filter(function (l) { return l.lineNumber.next != null; })
                .length,
        } });
}
function addExtraStuff(codeStep, code) {
    var vInterval = verticalInterval(codeStep.enterCount, codeStep.exitCount);
    var newGroups = map(codeStep.lineGroups, function (groups) {
        return groups.map(function (group) { return (__assign(__assign({}, group), { lines: getLinesWithElements(group.lines, vInterval, codeStep.enterCount, codeStep.exitCount) })); });
    });
    return __assign(__assign({}, codeStep), { groups: newGroups, verticalInterval: vInterval, code: code });
}
function verticalInterval(enterCount, exitCount) {
    if (enterCount <= 0 && exitCount <= 0)
        return [0, 1];
    if (enterCount <= 0 && exitCount >= 1)
        return [0.33, 1];
    if (enterCount >= 1 && exitCount <= 0)
        return [0, 0.67];
    return [0.25, 0.75];
}

function SmoothContainer(_a) {
    var dimensions = _a.dimensions, codeStep = _a.codeStep, children = _a.children, _b = _a.minZoom, minZoom = _b === void 0 ? 0 : _b, _c = _a.maxZoom, maxZoom = _c === void 0 ? 1.2 : _c, _d = _a.center, center = _d === void 0 ? false : _d, progress = _a.progress;
    var _e = getTweenContentProps({
        codeStep: codeStep,
        dimensions: dimensions,
        minZoom: minZoom,
        maxZoom: maxZoom,
        horizontalCenter: center,
    }), prev = _e.prev, next = _e.next;
    // all these tweens depends on annotations now (t instead of progress)
    var zoom = tweenProp(prev.zoom, next.zoom, progress);
    var dx = tweenProp(prev.dx, next.dx, progress);
    var dy = tweenProp(prev.dy, next.dy, progress, codeStep.verticalInterval);
    var focusHeight = tweenProp(prev.focusHeight, next.focusHeight, progress);
    var focusWidth = tweenProp(prev.focusWidth, next.focusWidth, progress);
    var lineNumberPad = ((dimensions === null || dimensions === void 0 ? void 0 : dimensions.lineNumberWidth) || 0) * zoom;
    var leftPad = lineNumberPad || 16;
    var width = Math.max(focusWidth + leftPad, dimensions.containerWidth);
    var startX = leftPad / zoom;
    return (React.createElement(Container, { width: dimensions.containerWidth, height: dimensions.containerHeight },
        React.createElement(Content, { dx: dx, dy: dy, scale: zoom, height: Math.max(focusHeight, dimensions.containerHeight), width: width }, children(focusWidth, startX))));
}
function Container(_a) {
    var width = _a.width, height = _a.height, children = _a.children;
    return (React.createElement("code", { style: {
            width: width,
            height: height,
            position: "relative",
            overflow: "auto",
        }, className: "ch-code-scroll-parent", children: children }));
}
function Content(_a) {
    var dx = _a.dx, dy = _a.dy, scale = _a.scale, height = _a.height, width = _a.width, children = _a.children;
    return (React.createElement("div", { style: {
            position: "absolute",
            top: 0,
            left: 0,
            transformOrigin: "top left",
            width: width,
            height: height,
            overflow: "hidden",
        }, className: "ch-code-scroll-content" },
        React.createElement("div", { style: {
                position: "absolute",
                top: 0,
                left: 0,
                transform: "translateX(" + dx + "px) translateY(" + dy + "px) scale(" + scale + ")",
                transformOrigin: "left top",
                width: width / scale,
                height: (height - 2 * dy) / scale,
            }, children: children })));
}
function getTweenContentProps(_a) {
    var codeStep = _a.codeStep, rest = __rest(_a, ["codeStep"]);
    var _b = rest.dimensions, lineHeight = _b.lineHeight, lineWidth = _b.lineWidth;
    var paramTween = {
        prev: {
            extremes: [
                codeStep.firstFocusedLineNumber.prev - 1,
                codeStep.lastFocusedLineNumber.prev - 1,
            ],
            originalContentHeight: codeStep.lineCount.prev * lineHeight,
            lineWidth: lineWidth[0],
        },
        next: {
            extremes: [
                codeStep.firstFocusedLineNumber.next - 1,
                codeStep.lastFocusedLineNumber.next - 1,
            ],
            originalContentHeight: codeStep.lineCount.next * lineHeight,
            lineWidth: lineWidth[1],
        },
    };
    return map(paramTween, function (_a) {
        var extremes = _a.extremes, originalContentHeight = _a.originalContentHeight, lineWidth = _a.lineWidth;
        return getContentProps(__assign({ extremes: extremes,
            originalContentHeight: originalContentHeight,
            lineWidth: lineWidth }, rest));
    });
}
function getContentProps(_a) {
    var dimensions = _a.dimensions, lineWidth = _a.lineWidth, minZoom = _a.minZoom, maxZoom = _a.maxZoom, extremes = _a.extremes, originalContentHeight = _a.originalContentHeight, horizontalCenter = _a.horizontalCenter;
    var _b = dimensions, containerWidth = _b.containerWidth, containerHeight = _b.containerHeight, lineHeight = _b.lineHeight;
    var originalFocusHeight = (extremes[1] - extremes[0] + 3) * lineHeight;
    var leftPadding = (dimensions === null || dimensions === void 0 ? void 0 : dimensions.lineNumberWidth) || 16;
    var rightPadding = 16;
    var zoom = Math.max(Math.min((containerWidth - leftPadding - rightPadding) /
        lineWidth, containerHeight / originalFocusHeight, maxZoom), minZoom);
    var contentHeight = originalContentHeight * zoom;
    var focusStart = (extremes[0] - 1) * lineHeight * zoom;
    var focusEnd = (extremes[1] + 2) * lineHeight * zoom;
    var focusCenter = (focusEnd + focusStart) / 2;
    var focusHeight = focusEnd - focusStart;
    var dy = containerHeight > contentHeight
        ? (containerHeight - contentHeight) / 2
        : clamp(containerHeight / 2 - focusCenter, Math.max(containerHeight - contentHeight, -focusStart // to ensure first focus line is shown when focus is bigger than container
        ), 0);
    var dx = horizontalCenter
        ? Math.max(containerWidth / 2 - (lineWidth * zoom) / 2, 0)
        : 0;
    return {
        zoom: zoom,
        dx: dx,
        dy: dy,
        focusHeight: focusHeight,
        focusWidth: lineWidth * zoom,
    };
}
function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
}
function tweenProp(start, end, progress, interval) {
    if (interval === void 0) { interval = [0, 1]; }
    return tween({
        fixed: false,
        interval: interval,
        extremes: [start, end],
        ease: easing.easeInOutCubic,
    }, progress);
}

function SmoothLines(props) {
    return (React.createElement(SmoothContainer, __assign({}, props), function (focusWidth, startX) { return (React.createElement(Lines, { codeStep: props.codeStep, focusWidth: focusWidth, lineHeight: props.dimensions.lineHeight, progress: props.progress, theme: props.theme, startX: startX, lineNumberWidth: props.dimensions.lineNumberWidth })); }));
}
function Lines(_a) {
    var codeStep = _a.codeStep, progress = _a.progress, focusWidth = _a.focusWidth, lineHeight = _a.lineHeight, startX = _a.startX, theme = _a.theme, lineNumberWidth = _a.lineNumberWidth;
    var groups = progress < 0.5
        ? codeStep.groups.prev
        : codeStep.groups.next;
    return (React.createElement(React.Fragment, null, groups.map(function (group, i) {
        if (!group.annotation) {
            return (React.createElement(LineGroup, { lines: group.lines, t: progress, focusWidth: focusWidth, lineHeight: lineHeight, startX: startX, key: i, theme: theme, lineNumberWidth: lineNumberWidth }));
        }
        var startY = tween(group.lines[0].tweenY, progress);
        var lineCount = group.annotation.lineNumbers.end -
            group.annotation.lineNumbers.start +
            1;
        var Component = group.annotation.Component;
        return (React.createElement(Component, { style: {
                position: "absolute",
                height: lineCount * lineHeight,
                width: "100%",
                transform: "translateY(" + startY * lineHeight + "px)",
            }, key: i, data: group.annotation.data, theme: group.annotation.theme },
            React.createElement(LineGroup, { lines: group.lines, t: progress, focusWidth: focusWidth, lineHeight: lineHeight, startY: startY, startX: startX, theme: theme, lineNumberWidth: lineNumberWidth })));
    })));
}
function LineGroup(_a) {
    var lines = _a.lines, focusWidth = _a.focusWidth, lineHeight = _a.lineHeight, t = _a.t, startX = _a.startX, _b = _a.startY, startY = _b === void 0 ? 0 : _b, theme = _a.theme, lineNumberWidth = _a.lineNumberWidth;
    return (React.createElement(React.Fragment, null, lines.map(function (line, key) {
        var tweenX = line.tweenX, tweenY = line.tweenY, focused = line.focused;
        var dx = tween(tweenX, t);
        var dy = tween(tweenY, t);
        var opacity = getOpacity(focused, t, dx);
        return (React.createElement(React.Fragment, { key: key },
            lineNumberWidth ? (React.createElement("span", { className: "ch-code-line-number", style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    transform: "translate(" + dx * focusWidth + "px, " + (dy - startY) * lineHeight + "px)",
                    width: lineNumberWidth,
                    opacity: opacity,
                    color: getColor(theme, ColorName.LineNumberForeground),
                } }, t < 0.5
                ? line.lineNumber.prev
                : line.lineNumber.next)) : undefined,
            React.createElement(LineContainer, { dx: startX + dx * focusWidth, dy: (dy - startY) * lineHeight, width: focusWidth, opacity: opacity },
                React.createElement(LineContent, { line: line, progress: t, dx: dx }))));
    })));
}
function LineContent(_a) {
    var line = _a.line, progress = _a.progress, dx = _a.dx;
    return (React.createElement("div", { style: {
            display: "inline-block",
            width: "100%",
        } },
        line.annotatedGroups.map(function (annotatedGroup, i) { return (React.createElement(AnnotatedTokens, { annotatedGroup: annotatedGroup, progress: progress, dx: dx, key: i })); }),
        React.createElement("br", null)));
}
function AnnotatedTokens(_a) {
    var _b, _c, _d;
    var annotatedGroup = _a.annotatedGroup, progress = _a.progress, dx = _a.dx;
    var annotated = progress < 0.5
        ? annotatedGroup.prev
        : annotatedGroup.next;
    var tokenGroups = (annotated === null || annotated === void 0 ? void 0 : annotated.groups) || [];
    var Component = (_b = annotated === null || annotated === void 0 ? void 0 : annotated.annotation) === null || _b === void 0 ? void 0 : _b.Component;
    var children = tokenGroups.map(function (group, i) {
        var opacity = getOpacity(group.focused, progress, dx);
        return (React.createElement("span", { style: { opacity: opacity }, key: i + 1 }, group.element));
    });
    return Component ? (React.createElement(Component, { children: children, data: (_c = annotated === null || annotated === void 0 ? void 0 : annotated.annotation) === null || _c === void 0 ? void 0 : _c.data, theme: (_d = annotated === null || annotated === void 0 ? void 0 : annotated.annotation) === null || _d === void 0 ? void 0 : _d.theme })) : (React.createElement(React.Fragment, null, children));
}
function LineContainer(_a) {
    var children = _a.children, dx = _a.dx, dy = _a.dy, opacity = _a.opacity, width = _a.width;
    return (React.createElement("div", { style: {
            position: "absolute",
            top: 0,
            left: 0,
            transform: "translate(" + dx + "px, " + dy + "px)",
            width: width,
            display: opacity <= 0 ? "none" : undefined,
        } }, children));
}
var OFF_OPACITY = 0.33;
function getOpacity(focused, progress, dx) {
    return (tween({
        fixed: false,
        extremes: [
            focused.prev ? 0.99 : OFF_OPACITY,
            focused.next ? 0.99 : OFF_OPACITY,
        ],
        interval: [0, 1],
    }, progress) -
        Math.abs(dx) * 1);
}

function useCodeShift(_a) {
    var tween = _a.tween, theme = _a.theme;
    return useStepParser({
        highlightedLines: map(tween, function (tween) { return tween.code.lines; }),
        theme: theme,
        focus: map(tween, function (tween) { return tween.focus; }),
        annotations: map(tween, function (tween) { return tween.annotations; }),
    });
}
var DEFAULT_MIN_COLUMNS = 10;
function CodeTween(_a) {
    var tween = _a.tween, progress = _a.progress, config = _a.config, preProps = __rest(_a, ["tween", "progress", "config"]);
    var stepInfo = useCodeShift({
        tween: tween,
        theme: config.theme,
    });
    var _b = useDimensions(stepInfo.code, map(tween, function (tween) { return tween.focus; }), config.minColumns || DEFAULT_MIN_COLUMNS, config.lineNumbers || false, [config.parentHeight]), element = _b.element, dimensions = _b.dimensions;
    // return (
    //   <BeforeDimensions
    //     element={element}
    //     htmlProps={preProps}
    //   />
    // )
    return !dimensions ? (React.createElement(BeforeDimensions, { element: element, htmlProps: preProps })) : (React.createElement(AfterDimensions, { dimensions: dimensions, stepInfo: stepInfo, config: config, progress: progress, htmlProps: preProps }));
}
function BeforeDimensions(_a) {
    var element = _a.element, htmlProps = _a.htmlProps;
    return (React.createElement(Wrapper, { htmlProps: htmlProps, 
        // avoid scrollbars when measuring
        style: { overflow: "hidden", opacity: 0 } }, element));
}
function AfterDimensions(_a) {
    var _b;
    var _c = _a.config, _d = _c.minZoom, minZoom = _d === void 0 ? 1 : _d, _e = _c.maxZoom, maxZoom = _e === void 0 ? 1 : _e, _f = _c.horizontalCenter, horizontalCenter = _f === void 0 ? false : _f, theme = _c.theme, dimensions = _a.dimensions, stepInfo = _a.stepInfo, progress = _a.progress, htmlProps = _a.htmlProps;
    var _g = getCodeColors(theme), bg = _g.bg, fg = _g.fg;
    return (React.createElement(Wrapper, { htmlProps: htmlProps, style: (_b = {
                opacity: 1,
                backgroundColor: bg,
                color: fg
            },
            _b["--ch-selection-background"] = getColor(theme, ColorName.SelectionBackground),
            _b) },
        React.createElement(SmoothLines, { codeStep: stepInfo, progress: progress, dimensions: dimensions, 
            // TODO move to dimensions?
            minZoom: minZoom, maxZoom: maxZoom, center: horizontalCenter, theme: theme })));
}
function Wrapper(_a) {
    var htmlProps = _a.htmlProps, style = _a.style, children = _a.children;
    return (React.createElement("div", __assign({}, htmlProps, { style: __assign(__assign({ margin: 0, padding: 0, 
            // using this instead of <pre> because https://github.com/code-hike/codehike/issues/120
            whiteSpace: "pre" }, style), htmlProps === null || htmlProps === void 0 ? void 0 : htmlProps.style), children: children })));
}

var defaultSpring = {
    stiffness: 120,
    damping: 24,
    mass: 0.2,
    decimals: 3,
};
function CodeSpring(_a) {
    var step = _a.step, config = _a.config, htmlProps = __rest(_a, ["step", "config"]);
    var _b = useStepSpring(step, config.spring), tween = _b.tween, t = _b.t;
    return (React.createElement(CodeTween, __assign({ tween: tween, progress: t, config: config }, htmlProps)));
}
function useStepSpring(step, springConfig) {
    if (springConfig === void 0) { springConfig = defaultSpring; }
    var _a = __read(React.useState({
        target: 0,
        tween: { prev: step, next: step },
    }), 2), _b = _a[0], target = _b.target, tween = _b.tween, setState = _a[1];
    React.useEffect(function () {
        if (tween.next != step) {
            setState(function (s) { return ({
                target: s.target + 1,
                tween: { prev: tween.next, next: step },
            }); });
        }
    }, [step]);
    var _c = __read(useSpring(target, springConfig), 1), progress = _c[0];
    var t = progress % 1;
    return { tween: tween, t: t || 1 };
}

export { CodeSpring, CodeTween };
