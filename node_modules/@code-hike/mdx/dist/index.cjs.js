'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var highlighter = require('@code-hike/highlighter');
var React = require('react');
var utils = require('@code-hike/utils');
var visit = require('unist-util-visit');
var isPlainObject = require('is-plain-obj');
var unified = require('unified');
var remarkRehype = require('remark-rehype');
var toEstree = require('hast-util-to-estree');
var fetch = require('node-fetch');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var visit__default = /*#__PURE__*/_interopDefaultLegacy(visit);
var isPlainObject__default = /*#__PURE__*/_interopDefaultLegacy(isPlainObject);
var unified__default = /*#__PURE__*/_interopDefaultLegacy(unified);
var remarkRehype__default = /*#__PURE__*/_interopDefaultLegacy(remarkRehype);
var toEstree__default = /*#__PURE__*/_interopDefaultLegacy(toEstree);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var annotationsMap = {
    box: Box,
    bg: Background,
    label: Label,
    link: CodeLink,
    mark: Mark,
};
function Mark(_a) {
    var children = _a.children, data = _a.data, theme = _a.theme;
    var bg = data && typeof data === "string"
        ? data
        : tryGuessColor(children) ||
            utils.transparent(utils.getColor(theme, utils.ColorName.CodeForeground), 0.2);
    return (React__default['default'].createElement("span", { className: "ch-code-mark-annotation", style: {
            background: bg,
            borderRadius: "0.25rem",
            padding: "0.2rem 0.15rem 0.1rem",
            margin: "0 -0.15rem",
        } }, children));
}
function tryGuessColor(children) {
    var _a, _b, _c;
    var child = React__default['default'].Children.toArray(children)[0];
    var grandChild = React__default['default'].Children.toArray(((_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.children) || [])[0];
    var grandGrandChild = React__default['default'].Children.toArray(((_b = grandChild === null || grandChild === void 0 ? void 0 : grandChild.props) === null || _b === void 0 ? void 0 : _b.children) || [])[0];
    var color = ((_c = grandGrandChild === null || grandGrandChild === void 0 ? void 0 : grandGrandChild.props) === null || _c === void 0 ? void 0 : _c.style).color;
    if (color) {
        return utils.transparent(color, 0.2);
    }
    return undefined;
}
function Box(_a) {
    var _b, _c;
    var children = _a.children, data = _a.data, theme = _a.theme;
    var border = typeof data === "string"
        ? data
        : ((_c = (_b = theme.tokenColors.find(function (tc) { var _a; return (_a = tc.scope) === null || _a === void 0 ? void 0 : _a.includes("string"); })) === null || _b === void 0 ? void 0 : _b.settings) === null || _c === void 0 ? void 0 : _c.foreground) || "yellow";
    return (React__default['default'].createElement("span", { className: "ch-code-box-annotation", style: { outline: "2px solid " + border } }, children));
}
function Background(_a) {
    var children = _a.children, data = _a.data, style = _a.style, theme = _a.theme;
    var bg = data ||
        (theme.colors["editor.lineHighlightBackground"] ||
            theme.colors["editor.selectionHighlightBackground"]);
    return (React__default['default'].createElement("div", { style: __assign(__assign({}, style), { background: bg }), className: "ch-code-bg-annotation" },
        React__default['default'].createElement("span", { className: "ch-code-bg-annotation-border", style: {
                background: "#00a2d3",
                width: "3px",
                height: "100%",
                position: "absolute",
                left: 0,
            } }),
        children));
}
function Label(_a) {
    var children = _a.children, data = _a.data, style = _a.style, theme = _a.theme;
    var bg = (theme.colors["editor.lineHighlightBackground"] ||
        theme.colors["editor.selectionHighlightBackground"]);
    var _b = __read(React__default['default'].useState(false), 2), hover = _b[0], setHover = _b[1];
    return (React__default['default'].createElement("div", { style: __assign(__assign({}, style), { background: hover ? bg : undefined }), onMouseEnter: function () { return setHover(true); }, onMouseLeave: function () { return setHover(false); } },
        children,
        React__default['default'].createElement("div", { style: {
                position: "absolute",
                right: 0,
                paddingRight: 16,
                display: hover ? "block" : "none",
                opacity: 0.7,
            } }, (data === null || data === void 0 ? void 0 : data.children) || data)));
}
function CodeLink(_a) {
    var _b, _c;
    var children = _a.children, data = _a.data;
    var url = ((_b = data) === null || _b === void 0 ? void 0 : _b.url) || data;
    var title = (_c = data) === null || _c === void 0 ? void 0 : _c.title;
    return (React__default['default'].createElement("a", { href: url, target: "_blank", rel: "noopener noreferrer", title: title, style: {
            textDecoration: "underline",
            textDecorationStyle: "dotted",
            color: "inherit",
        } }, children));
}

function extractLinks(node, index, parent, code) {
    var annotations = [];
    var nextIndex = index + 1;
    var _loop_1 = function () {
        var _a = parent.children[nextIndex], identifier = _a.identifier, url = _a.url, title = _a.title;
        var focusList = getFocusList(identifier, code);
        focusList.forEach(function (focus) {
            annotations.push({
                Component: annotationsMap["link"],
                focus: focus,
                data: {
                    url: url,
                    title: title,
                },
            });
        });
        parent.children.splice(nextIndex, 1);
    };
    while (parent.children[nextIndex] &&
        parent.children[nextIndex].type === "definition") {
        _loop_1();
    }
    return annotations;
}
var newlineRe = /\r\n|\r|\n/;
function getFocusList(identifier, code) {
    var lines = code.split(newlineRe);
    var focusList = [];
    lines.forEach(function (line, index) {
        var lineNumber = index + 1;
        var re = new RegExp(identifier, "g");
        var match = re.exec(line);
        while (match) {
            var columnStart = match.index + 1;
            var columnEnd = columnStart + identifier.length - 1;
            focusList.push(lineNumber + "[" + columnStart + ":" + columnEnd + "]");
            match = re.exec(line);
        }
    });
    return focusList;
}

/**
 * Convert a value to an ESTree node
 *
 * @param value - The value to convert
 * @param options - Additional options to configure the output.
 * @returns The ESTree node.
 */
function valueToEstree(value, options) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    if (value === undefined) {
        return { type: "Identifier", name: "undefined" };
    }
    if (value == null) {
        return { type: "Literal", value: null, raw: "null" };
    }
    if (value === Number.POSITIVE_INFINITY) {
        return { type: "Identifier", name: "Infinity" };
    }
    if (Number.isNaN(value)) {
        return { type: "Identifier", name: "NaN" };
    }
    if (typeof value === "boolean") {
        return { type: "Literal", value: value, raw: String(value) };
    }
    if (typeof value === "bigint") {
        return value >= 0
            ? {
                type: "Literal",
                value: value,
                raw: value + "n",
                bigint: String(value),
            }
            : {
                type: "UnaryExpression",
                operator: "-",
                prefix: true,
                argument: valueToEstree(-value, options),
            };
    }
    if (typeof value === "number") {
        return value >= 0
            ? { type: "Literal", value: value, raw: String(value) }
            : {
                type: "UnaryExpression",
                operator: "-",
                prefix: true,
                argument: valueToEstree(-value, options),
            };
    }
    if (typeof value === "string") {
        return {
            type: "Literal",
            value: value,
            raw: JSON.stringify(value),
        };
    }
    if (typeof value === "symbol") {
        if (value.description &&
            value === Symbol["for"](value.description)) {
            return {
                type: "CallExpression",
                optional: false,
                callee: {
                    type: "MemberExpression",
                    computed: false,
                    optional: false,
                    object: { type: "Identifier", name: "Symbol" },
                    property: { type: "Identifier", name: "for" },
                },
                arguments: [
                    valueToEstree(value.description, options),
                ],
            };
        }
        throw new TypeError("Only global symbols are supported, got: " + String(value));
    }
    if (Array.isArray(value)) {
        var elements = [];
        for (var i = 0; i < value.length; i += 1) {
            elements.push(i in value ? valueToEstree(value[i], options) : null);
        }
        return { type: "ArrayExpression", elements: elements };
    }
    if (value instanceof RegExp) {
        return {
            type: "Literal",
            value: value,
            raw: String(value),
            regex: { pattern: value.source, flags: value.flags },
        };
    }
    if (value instanceof Date) {
        return {
            type: "NewExpression",
            callee: { type: "Identifier", name: "Date" },
            arguments: [valueToEstree(value.getTime(), options)],
        };
    }
    if (value instanceof Map) {
        return {
            type: "NewExpression",
            callee: { type: "Identifier", name: "Map" },
            arguments: [
                valueToEstree(__spread(value.entries()), options),
            ],
        };
    }
    if (value instanceof BigInt64Array ||
        value instanceof BigUint64Array ||
        value instanceof Float32Array ||
        value instanceof Float64Array ||
        value instanceof Int8Array ||
        value instanceof Int16Array ||
        value instanceof Int32Array ||
        value instanceof Set ||
        value instanceof Uint8Array ||
        value instanceof Uint8ClampedArray ||
        value instanceof Uint16Array ||
        value instanceof Uint32Array) {
        return {
            type: "NewExpression",
            callee: {
                type: "Identifier",
                name: value.constructor.name,
            },
            arguments: [valueToEstree(__spread(value), options)],
        };
    }
    if (value instanceof URL ||
        value instanceof URLSearchParams) {
        return {
            type: "NewExpression",
            callee: {
                type: "Identifier",
                name: value.constructor.name,
            },
            arguments: [valueToEstree(String(value), options)],
        };
    }
    if (options.instanceAsObject || isPlainObject__default['default'](value)) {
        if (((_a = value) === null || _a === void 0 ? void 0 : _a.name) === MDX_CHILDREN) {
            var tree = __assign({}, value);
            tree.name = null;
            return mdastToEstree(tree).body[0].expression;
        }
        if (((_b = value) === null || _b === void 0 ? void 0 : _b.type) ===
            "mdxJsxAttributeValueExpression") {
            return value.data.estree.body[0].expression;
        }
        return {
            type: "ObjectExpression",
            // @ts-expect-error: looks like an object.
            properties: Object.entries(value).map(function (_a) {
                var _b = __read(_a, 2), name = _b[0], val = _b[1];
                return ({
                    type: "Property",
                    method: false,
                    shorthand: false,
                    computed: false,
                    kind: "init",
                    key: valueToEstree(name, options),
                    value: valueToEstree(val, options),
                });
            }),
        };
    }
    var isAnnotation = Object.values(annotationsMap).includes(value);
    // code hike annotations patch
    if (isAnnotation) {
        var identifier = Object.keys(annotationsMap).find(function (key) { return annotationsMap[key] === value; });
        return {
            type: "MemberExpression",
            object: {
                type: "MemberExpression",
                object: {
                    type: "Identifier",
                    name: "CH",
                },
                property: {
                    type: "Identifier",
                    name: "annotations",
                },
                computed: false,
                optional: false,
            },
            property: {
                type: "Identifier",
                name: identifier,
            },
            computed: false,
            optional: false,
        };
    }
    throw new TypeError("Unsupported value: " + String(value));
}
function mdastToEstree(node) {
    var nodeTypes = [
        "mdxFlowExpression",
        "mdxJsxFlowElement",
        "mdxJsxTextElement",
        "mdxTextExpression",
        "mdxjsEsm",
    ];
    var changedTree = unified__default['default']()
        .use(remarkRehype__default['default'], {
        allowDangerousHtml: true,
        passThrough: nodeTypes,
    })
        .use(rehypeRecma)
        .runSync(node);
    return changedTree;
}
function rehypeRecma() {
    return function (tree) { return toEstree__default['default'](tree); };
}
var MDX_CHILDREN = "MDX_CHILDREN";
function wrapChildren(children) {
    var tree = {
        type: "mdxJsxFlowElement",
        children: children,
        name: MDX_CHILDREN,
    };
    return tree;
}

function splitChildren(parent, type) {
    var splits = [];
    var i = 0;
    parent.children.forEach(function (node, index) {
        if (node.type === type) {
            i++;
        }
        else {
            if (!splits[i]) {
                splits[i] = [];
            }
            splits[i].push({ node: node, index: index, parent: parent });
        }
    });
    return splits;
}
function visitAsync(tree, type, visitor) {
    return __awaiter(this, void 0, void 0, function () {
        var promises;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    promises = [];
                    visit__default['default'](tree, type, function (node, index, parent) {
                        var result = visitor(node, index, parent);
                        if (result) {
                            promises.push(result);
                        }
                    });
                    return [4 /*yield*/, Promise.all(promises)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
var CH_CODE_CONFIG_PLACEHOLDER = "CH_CodeConfig";
var CH_CODE_CONFIG_VAR_NAME = "chCodeConfig";
function toJSX(node, _a) {
    var _b = _a.type, type = _b === void 0 ? "mdxJsxFlowElement" : _b, props = _a.props, name = _a.name, _c = _a.appendProps, appendProps = _c === void 0 ? false : _c;
    // console.log(`transforming ${node.name} to ${name}`)
    node.type = type;
    if (name) {
        node.name = name;
    }
    if (!appendProps) {
        node.attributes = [];
    }
    else {
        node.attributes = node.attributes || [];
    }
    Object.keys(props).forEach(function (key) {
        if (props[key] === undefined) {
            return;
        }
        if (props[key] === CH_CODE_CONFIG_PLACEHOLDER) {
            node.attributes.push({
                type: "mdxJsxAttribute",
                name: key,
                value: {
                    type: "mdxJsxAttributeValueExpression",
                    value: CH_CODE_CONFIG_VAR_NAME,
                    data: {
                        estree: {
                            type: "Program",
                            body: [
                                {
                                    type: "ExpressionStatement",
                                    expression: {
                                        type: "Identifier",
                                        name: CH_CODE_CONFIG_VAR_NAME,
                                    },
                                },
                            ],
                            sourceType: "module",
                        },
                    },
                },
            });
        }
        else {
            node.attributes.push({
                type: "mdxJsxAttribute",
                name: key,
                value: {
                    type: "mdxJsxAttributeValueExpression",
                    value: JSON.stringify(props[key]),
                    data: {
                        estree: {
                            type: "Program",
                            body: [
                                {
                                    type: "ExpressionStatement",
                                    expression: valueToEstree(props[key]),
                                },
                            ],
                            sourceType: "module",
                        },
                    },
                },
            });
        }
    });
}

function getAnnotationsFromMetastring(options) {
    var annotations = [];
    Object.keys(options).forEach(function (key) {
        var Component = annotationsMap[key];
        if (Component) {
            annotations === null || annotations === void 0 ? void 0 : annotations.push({ focus: options[key], Component: Component });
        }
    });
    return annotations;
}
function extractAnnotationsFromCode(code) {
    var lines = code.lines;
    var lineNumber = 1;
    var annotations = [];
    var focusList = [];
    while (lineNumber <= lines.length) {
        var line = lines[lineNumber - 1];
        var _a = getCommentData(line), key = _a.key, focusString = _a.focusString, data = _a.data;
        // console.log({ key, focusString, data })
        var Component = annotationsMap[key];
        if (Component) {
            var focus_1 = utils.relativeToAbsolute(focusString, lineNumber);
            lines.splice(lineNumber - 1, 1);
            annotations.push({ Component: Component, focus: focus_1, data: data });
        }
        else if (key === "focus") {
            var focus_2 = utils.relativeToAbsolute(focusString, lineNumber);
            lines.splice(lineNumber - 1, 1);
            focusList.push(focus_2);
        }
        else {
            lineNumber++;
        }
    }
    return [annotations, focusList.join(",")];
}
var commentRegex = /\/\/\s+(\w+)(\S*)\s*(.*)/;
function getCommentData(line) {
    var _a;
    var comment = (_a = line.tokens.find(function (t) {
        return t.content.trim().startsWith("//");
    })) === null || _a === void 0 ? void 0 : _a.content;
    if (!comment) {
        return {};
    }
    var result = commentRegex.exec(comment);
    if (!result) {
        return {};
    }
    var _b = __read(result, 4), key = _b[1], focusString = _b[2], data = _b[3];
    return {
        key: key,
        focusString: focusString,
        data: data,
    };
}
function extractJSXAnnotations(node, index, parent) {
    var annotations = [];
    var nextIndex = index + 1;
    var _loop_1 = function () {
        var jsxAnnotation = parent.children[nextIndex];
        // copy attributes to props
        var props = {};
        jsxAnnotation.attributes.forEach(function (attr) {
            props[attr.name] = attr.value;
        });
        var as = props.as, focus_3 = props.focus, data = __rest(props, ["as", "focus"]);
        data.children = wrapChildren(jsxAnnotation.children || []);
        var Component = annotationsMap[as] || as;
        annotations.push({
            Component: Component,
            focus: focus_3,
            data: isEmpty$1(data) ? undefined : data,
        });
        // console.log(jsxAnnotation)
        parent.children.splice(nextIndex, 1);
    };
    while (parent.children[nextIndex] &&
        parent.children[nextIndex].type ===
            "mdxJsxFlowElement" &&
        parent.children[nextIndex].name === "CH.Annotation") {
        _loop_1();
    }
    return annotations;
}
function isEmpty$1(obj) {
    return Object.keys(obj).length === 0;
}

function transformCodeNodes(tree, _a) {
    var theme = _a.theme;
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "code", function (node, index, parent) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, transformCode({ node: node, index: index, parent: parent }, { theme: theme })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function isEditorNode(node) {
    return (node.type === "code" ||
        (node.type === "mdxJsxFlowElement" &&
            node.name === "CH.Code"));
}
function transformCode(nodeInfo, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = toJSX;
                    _b = [nodeInfo.node];
                    _c = {
                        name: "CH.Code"
                    };
                    return [4 /*yield*/, mapCode(nodeInfo, config)];
                case 1:
                    _a.apply(void 0, _b.concat([(_c.props = _d.sent(),
                            _c)]));
                    return [2 /*return*/];
            }
        });
    });
}
function transformEditor(nodeInfo, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = toJSX;
                    _b = [nodeInfo.node];
                    _c = {
                        name: "CH.Code"
                    };
                    return [4 /*yield*/, mapEditor(nodeInfo, config)];
                case 1:
                    _a.apply(void 0, _b.concat([(_c.props = _d.sent(),
                            _c)]));
                    return [2 /*return*/];
            }
        });
    });
}
function mapAnyCodeNode(nodeInfo, config) {
    return __awaiter(this, void 0, void 0, function () {
        var node;
        return __generator(this, function (_a) {
            node = nodeInfo.node;
            if (node.type === "code") {
                return [2 /*return*/, mapCode(nodeInfo, config)];
            }
            else {
                return [2 /*return*/, mapEditor(nodeInfo, config)];
            }
        });
    });
}
function mapCode(nodeInfo, config) {
    return __awaiter(this, void 0, void 0, function () {
        var file, props;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, mapFile(nodeInfo, config)];
                case 1:
                    file = _a.sent();
                    props = {
                        northPanel: {
                            tabs: [file.name],
                            active: file.name,
                            heightRatio: 1,
                        },
                        files: [file],
                        codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                    };
                    return [2 /*return*/, props];
            }
        });
    });
}
function mapEditor(_a, config) {
    var node = _a.node;
    return __awaiter(this, void 0, void 0, function () {
        var _b, northNodes, _c, southNodes, northFiles, southFiles, allFiles, northActive, southActive, northLines, southLines, northRatio, southRatio, props;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _b = __read(splitChildren(node, "thematicBreak"), 2), northNodes = _b[0], _c = _b[1], southNodes = _c === void 0 ? [] : _c;
                    return [4 /*yield*/, Promise.all(northNodes
                            .filter(function (_a) {
                            var node = _a.node;
                            return node.type === "code";
                        })
                            .map(function (nodeInfo) { return mapFile(nodeInfo, config); }))];
                case 1:
                    northFiles = _d.sent();
                    return [4 /*yield*/, Promise.all(southNodes
                            .filter(function (_a) {
                            var node = _a.node;
                            return node.type === "code";
                        })
                            .map(function (nodeInfo) { return mapFile(nodeInfo, config); }))];
                case 2:
                    southFiles = _d.sent();
                    allFiles = __spread(northFiles, southFiles);
                    northActive = northFiles.find(function (f) { return f.active; }) || northFiles[0];
                    southActive = southFiles.length
                        ? southFiles.find(function (f) { return f.active; }) || southFiles[0]
                        : null;
                    northLines = northActive.code.lines.length || 1;
                    southLines = (southActive === null || southActive === void 0 ? void 0 : southActive.code.lines.length) || 0;
                    northRatio = southActive
                        ? (northLines + 2) / (southLines + northLines + 4)
                        : 1;
                    southRatio = 1 - northRatio;
                    props = {
                        northPanel: {
                            tabs: northFiles.map(function (x) { return x.name; }),
                            active: northActive.name,
                            heightRatio: northRatio,
                        },
                        southPanel: southFiles.length
                            ? {
                                tabs: southFiles.map(function (x) { return x.name; }),
                                active: southActive.name,
                                heightRatio: southRatio,
                            }
                            : undefined,
                        files: allFiles,
                        codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                    };
                    return [2 /*return*/, props];
            }
        });
    });
}
function mapFile(_a, config) {
    var node = _a.node, index = _a.index, parent = _a.parent;
    return __awaiter(this, void 0, void 0, function () {
        var theme, lang, code, _b, commentAnnotations, commentFocus, options, metaAnnotations, jsxAnnotations, file;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    theme = config.theme;
                    lang = node.lang || "text";
                    return [4 /*yield*/, highlighter.highlight({
                            code: node.value,
                            lang: lang,
                            theme: theme,
                        })];
                case 1:
                    code = _c.sent();
                    _b = __read(extractAnnotationsFromCode(code), 2), commentAnnotations = _b[0], commentFocus = _b[1];
                    options = parseMetastring(typeof node.meta === "string" ? node.meta : "");
                    metaAnnotations = getAnnotationsFromMetastring(options);
                    extractLinks(node, index, parent, node.value);
                    jsxAnnotations = extractJSXAnnotations(node, index, parent);
                    file = __assign(__assign({}, options), { focus: utils.mergeFocus(options.focus, commentFocus), code: code, name: options.name || "", annotations: __spread(metaAnnotations, commentAnnotations, jsxAnnotations) });
                    return [2 /*return*/, file];
            }
        });
    });
}
function parseMetastring(metastring) {
    var params = metastring.split(" ");
    var options = {};
    var name = null;
    params.forEach(function (param) {
        var _a = __read(param.split("="), 2), key = _a[0], value = _a[1];
        if (value != null) {
            options[key] = value;
        }
        else if (name === null) {
            name = key;
        }
        else {
            options[key] = true;
        }
    });
    return __assign({ name: name || "" }, options);
}

function transformEditorNodes(tree, _a) {
    var theme = _a.theme;
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "mdxJsxFlowElement", function (node, index, parent) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(node.name === "CH.Code")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, transformEditor({ node: node, index: index, parent: parent }, { theme: theme })];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    });
}

function transformSections(tree, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "mdxJsxFlowElement", function (sectionNode) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(sectionNode.name === "CH.Section")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, transformSection(sectionNode, config)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function transformSection(node, config) {
    return __awaiter(this, void 0, void 0, function () {
        var props;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(node, ["mdxJsxFlowElement", "code"], function (node, index, parent) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!isEditorNode(node)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, mapAnyCodeNode({ node: node, index: index, parent: parent }, config)];
                                case 1:
                                    props = _a.sent();
                                    toJSX(node, { name: "CH.SectionCode", props: {} });
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    transformLinks(node);
                    if (props) {
                        toJSX(node, { name: "CH.Section", props: props });
                    }
                    else {
                        toJSX(node, { name: "div", props: {} });
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function transformLinks(tree) {
    visit__default['default'](tree, "link", function (linkNode) {
        var url = decodeURI(linkNode["url"]);
        if (url.startsWith("focus://")) {
            var _a = __read(decodeURI(url)
                .substr("focus://".length)
                .split("#"), 2), firstPart = _a[0], secondPart = _a[1];
            var hasFile = Boolean(secondPart);
            var props = hasFile
                ? { file: firstPart, focus: secondPart, id: url }
                : { focus: firstPart, id: url };
            toJSX(linkNode, {
                type: "mdxJsxTextElement",
                name: "CH.SectionLink",
                props: props,
            });
        }
    });
}

// extend steps with info from previous steps
function reduceSteps(baseStep, extraStep) {
    var files = reduceFiles(baseStep.files, extraStep.files);
    return __assign(__assign(__assign({}, baseStep), extraStep), { files: files, northPanel: reducePanel(baseStep.northPanel, extraStep.northPanel, extraStep.southPanel), southPanel: reducePanel(baseStep.southPanel, extraStep.southPanel, extraStep.northPanel) });
}
function reducePanel(oldPanel, newPanel, otherNewPanel) {
    var _a, _b;
    if (!newPanel) {
        return newPanel;
    }
    var oldTabsStillThere = ((_a = oldPanel === null || oldPanel === void 0 ? void 0 : oldPanel.tabs) === null || _a === void 0 ? void 0 : _a.filter(function (name) { var _a; return !((_a = otherNewPanel === null || otherNewPanel === void 0 ? void 0 : otherNewPanel.tabs) === null || _a === void 0 ? void 0 : _a.includes(name)); })) || [];
    var realNewTabs = ((_b = newPanel === null || newPanel === void 0 ? void 0 : newPanel.tabs) === null || _b === void 0 ? void 0 : _b.filter(function (name) { var _a; return !((_a = oldPanel === null || oldPanel === void 0 ? void 0 : oldPanel.tabs) === null || _a === void 0 ? void 0 : _a.includes(name)); })) || [];
    return __assign(__assign(__assign({}, oldPanel), newPanel), { tabs: __spread(oldTabsStillThere, realNewTabs) });
}
function reduceFiles(baseFiles, extraFiles) {
    var filesMap = {};
    baseFiles.forEach(function (f) { return (filesMap[f.name] = f); });
    extraFiles.forEach(function (ef) {
        var bf = filesMap[ef.name];
        if (!bf) {
            filesMap[ef.name] = ef;
            return;
        }
        // merge old and new files
        var code = ef.code, rest = __rest(ef, ["code"]);
        if (isEmpty(code)) {
            filesMap[ef.name] = __assign(__assign({}, bf), rest);
        }
        else {
            filesMap[ef.name] = ef;
        }
    });
    var result = [];
    baseFiles.forEach(function (f) {
        result.push(filesMap[f.name]);
        delete filesMap[f.name];
    });
    extraFiles.forEach(function (f) { return filesMap[f.name] && result.push(filesMap[f.name]); });
    return result;
}
function isEmpty(code) {
    var anyContent = code.lines.some(function (l) {
        return l.tokens.some(function (t) { return t.content.trim() == ""; });
    });
    return !anyContent;
}

// extract step info
function extractStepsInfo(parent, config, merge) {
    return __awaiter(this, void 0, void 0, function () {
        var steps, stepIndex, children, i, child, step, _a, editorStep, baseStep;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    steps = [];
                    stepIndex = 0;
                    children = parent.children || [];
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < children.length)) return [3 /*break*/, 5];
                    child = children[i];
                    if (child.type === "thematicBreak") {
                        stepIndex++;
                        return [3 /*break*/, 4];
                    }
                    steps[stepIndex] = steps[stepIndex] || { children: [] };
                    step = steps[stepIndex];
                    if (!(!step.editorStep && isEditorNode(child))) return [3 /*break*/, 3];
                    return [4 /*yield*/, mapAnyCodeNode({ node: child, parent: parent, index: i }, config)];
                case 2:
                    _a = _b.sent(), _a.codeConfig, editorStep = __rest(_a, ["codeConfig"]);
                    if (stepIndex === 0) {
                        // for the header props, keep it as it is
                        step.editorStep = editorStep;
                    }
                    else {
                        baseStep = merge === "merge steps with header"
                            ? steps[0].editorStep
                            : steps[stepIndex - 1].editorStep;
                        step.editorStep = reduceSteps(baseStep, editorStep);
                    }
                    return [3 /*break*/, 4];
                case 3:
                    step.children.push(child);
                    _b.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 1];
                case 5:
                    parent.children = steps.map(function (step) {
                        return {
                            type: "mdxJsxFlowElement",
                            children: step.children,
                        };
                    });
                    return [2 /*return*/, steps.map(function (step) { return step.editorStep; })];
            }
        });
    });
}

function getPresetConfig(attributes) {
    return __awaiter(this, void 0, void 0, function () {
        var presetAttribute, url, prefix, csbid, configUrl, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    presetAttribute = attributes === null || attributes === void 0 ? void 0 : attributes.find(function (attr) { return attr.name === "preset"; });
                    if (!presetAttribute)
                        return [2 /*return*/, undefined];
                    url = presetAttribute.value;
                    prefix = "https://codesandbox.io/s/";
                    csbid = url.slice(prefix.length);
                    configUrl = "https://codesandbox.io/api/v1/sandboxes/" + csbid + "/sandpack";
                    return [4 /*yield*/, fetch__default['default'](configUrl)];
                case 1:
                    res = _a.sent();
                    return [4 /*yield*/, res.json()];
                case 2: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function transformPreviews(tree) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "mdxJsxFlowElement", function (node) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(node.name === "CH.Preview")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, transformPreview(node)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function transformPreview(node) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            toJSX(node, {
                props: {
                    codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                },
                appendProps: true,
            });
            return [2 /*return*/];
        });
    });
}

function transformSpotlights(tree, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "mdxJsxFlowElement", function (node) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(node.name === "CH.Spotlight")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, transformSpotlight(node, config)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function transformSpotlight(node, _a) {
    var theme = _a.theme;
    return __awaiter(this, void 0, void 0, function () {
        var editorSteps, presetConfig;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, extractStepsInfo(node, { theme: theme }, "merge steps with header")];
                case 1:
                    editorSteps = _b.sent();
                    return [4 /*yield*/, getPresetConfig(node.attributes)];
                case 2:
                    presetConfig = _b.sent();
                    toJSX(node, {
                        props: {
                            codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                            editorSteps: editorSteps,
                            presetConfig: presetConfig,
                        },
                        appendProps: true,
                    });
                    return [2 /*return*/];
            }
        });
    });
}

function transformScrollycodings(tree, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "mdxJsxFlowElement", function (node) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(node.name === "CH.Scrollycoding")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, transformScrollycoding(node, config)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function transformScrollycoding(node, _a) {
    var theme = _a.theme;
    return __awaiter(this, void 0, void 0, function () {
        var editorSteps, presetConfig;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, extractStepsInfo(node, { theme: theme }, "merge step with previous")];
                case 1:
                    editorSteps = _b.sent();
                    return [4 /*yield*/, getPresetConfig(node.attributes)];
                case 2:
                    presetConfig = _b.sent();
                    toJSX(node, {
                        props: {
                            codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                            editorSteps: editorSteps,
                            presetConfig: presetConfig,
                        },
                        appendProps: true,
                    });
                    return [2 /*return*/];
            }
        });
    });
}

function transformSlideshows(tree, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, "mdxJsxFlowElement", function (node) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(node.name === "CH.Slideshow")) return [3 /*break*/, 2];
                                    return [4 /*yield*/, transformSlideshow(node, config)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function transformSlideshow(node, _a) {
    var theme = _a.theme;
    return __awaiter(this, void 0, void 0, function () {
        var editorSteps, presetConfig;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, extractStepsInfo(node, { theme: theme }, "merge step with previous")];
                case 1:
                    editorSteps = _b.sent();
                    return [4 /*yield*/, getPresetConfig(node.attributes)];
                case 2:
                    presetConfig = _b.sent();
                    toJSX(node, {
                        props: {
                            codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                            editorSteps: editorSteps,
                            presetConfig: presetConfig,
                        },
                        appendProps: true,
                    });
                    return [2 /*return*/];
            }
        });
    });
}

function transformInlineCodes(tree) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visitAsync(tree, ["mdxJsxFlowElement", "mdxJsxTextElement"], function (node) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (node.name === "CH.InlineCode") {
                                toJSX(node, {
                                    props: {
                                        codeConfig: CH_CODE_CONFIG_PLACEHOLDER,
                                    },
                                    appendProps: true,
                                });
                            }
                            return [2 /*return*/];
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}

function remarkCodeHike(config) {
    var _this = this;
    return function (tree) { return __awaiter(_this, void 0, void 0, function () {
        var hasCodeHikeImport, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    hasCodeHikeImport = false;
                    visit__default['default'](tree, "mdxjsEsm", function (node) {
                        if (node.value.startsWith("import { CH } from \"@code-hike/mdx\"")) {
                            hasCodeHikeImport = true;
                        }
                    });
                    addConfig(tree, config);
                    if (!hasCodeHikeImport) {
                        addImportNode(tree);
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 10, , 11]);
                    return [4 /*yield*/, transformInlineCodes(tree)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, transformPreviews(tree)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, transformScrollycodings(tree, config)];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, transformSpotlights(tree, config)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, transformSlideshows(tree, config)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, transformSections(tree, config)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, transformEditorNodes(tree, config)];
                case 8:
                    _a.sent();
                    return [4 /*yield*/, transformCodeNodes(tree, config)];
                case 9:
                    _a.sent();
                    return [3 /*break*/, 11];
                case 10:
                    e_1 = _a.sent();
                    console.error("error running remarkCodeHike", e_1);
                    throw e_1;
                case 11: return [2 /*return*/];
            }
        });
    }); };
}
function addConfig(tree, config) {
    tree.children.unshift({
        type: "mdxjsEsm",
        value: "export const chCodeConfig = {}",
        data: {
            estree: {
                type: "Program",
                body: [
                    {
                        type: "ExportNamedDeclaration",
                        declaration: {
                            type: "VariableDeclaration",
                            declarations: [
                                {
                                    type: "VariableDeclarator",
                                    id: {
                                        type: "Identifier",
                                        name: CH_CODE_CONFIG_VAR_NAME,
                                    },
                                    init: valueToEstree(config),
                                },
                            ],
                            kind: "const",
                        },
                        specifiers: [],
                        source: null,
                    },
                ],
                sourceType: "module",
            },
        },
    });
}
function addImportNode(tree) {
    tree.children.unshift({
        type: "mdxjsEsm",
        value: 'import { CH } from "@code-hike/mdx"',
        data: {
            estree: {
                type: "Program",
                body: [
                    {
                        type: "ImportDeclaration",
                        specifiers: [
                            {
                                type: "ImportSpecifier",
                                imported: {
                                    type: "Identifier",
                                    name: "CH",
                                },
                                local: {
                                    type: "Identifier",
                                    name: "CH",
                                },
                            },
                        ],
                        source: {
                            type: "Literal",
                            value: "@code-hike/mdx/dist/components.cjs.js",
                            raw: '"@code-hike/mdx/dist/components.cjs.js"',
                        },
                    },
                ],
                sourceType: "module",
            },
        },
    });
}

exports.remarkCodeHike = remarkCodeHike;
